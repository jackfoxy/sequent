::  /lib/seq/hoon
::
::    operations for working with values of type list
::  ^seq
|%
::    +all-pairs: [(list t1) (list t2)] -> (list [t1 t2])
::
::  Returns a new list that contains all pairings of elements from two non-empty
::  lists.
::    Source
::      ++  all-pairs
::        |*  [p=(list) q=(list)]
::        =/  a=(list _?>(?=(^ p) i.p))  p
::        =/  res=(list [_?>(?=(^ p) i.p) _?>(?=(^ q) i.q)])  ~
::        =/  scnd=(list _?>(?=(^ q) i.q))  q
::        |-  ^-  (list [_?>(?=(^ p) i.p) _?>(?=(^ q) i.q)])
::        ?~  a  res
::        ?~  scnd  $(a t.a, scnd q)
::        $(res [[i.a i.scnd] res], scnd +.scnd)
::    Examples
::      > (all-pairs ~['a' 'b' 'c'] ~[1 2 3])
::      ~[['c' 3] ['c' 2] ['c' 1] 
::        ['b' 3] ['b' 2] ['b' 1]
::        ['a' 3] ['a' 2] ['a' 1]] 
++  all-pairs
  |*  [p=(list) q=(list)]
  =/  a=(list _?>(?=(^ p) i.p))  p
  =/  res=(list [_?>(?=(^ p) i.p) _?>(?=(^ q) i.q)])  ~
  =/  scnd=(list _?>(?=(^ q) i.q))  q
  |-  ^-  (list [_?>(?=(^ p) i.p) _?>(?=(^ q) i.q)])
  ?~  a  res
  ?~  scnd  $(a t.a, scnd q)
  $(res [[i.a i.scnd] res], scnd +.scnd)
::    +append: [(list) (list)] -> (list)
::
::  Returns a new list that contains the elements of the first list followed by
::  elements of the second list.
::    Source
::      ++  weld
::        ~/  %weld
::        |*  [a=(list) b=(list)]
::        =>  .(a ^.(homo a), b ^.(homo b))
::        |-  ^+  b
::        ?~  a  b
::        [i.a $(a t.a)]
::    Examples
::      > (append "urb" "it")
::      "urbit"
::      > (append (limo [1 2 ~]) (limo [3 4 ~]))
::      ~[1 2 3 4]
++  append  weld
::    +average: (list @) -> @ud
::
::  Returns the average of the values in a non-empty list.
::    Source
::      ++  average
::        |*  a=(list @)
::        (div (roll a add) (lent a))
::    Examples
::      > (average `(list @ud)`~[1 2 3 4])                                    â”‚
::      2
++  average
  |*  a=(list @)
  (div (roll a add) (lent a))
::    +average-by: [(list *) projection:$-(* @ud)] -> @ud
::
::  Returns the average of values in a list generated by applying a function to
::  each element of the list.
::    Source
::      ++  average-by
::        |*  [a=(list) b=$-(* @ud)]
::        (div (roll (turn a b) add) (lent a))
::    Examples
::      > (average-by (limo ~[[1 1] [2 2] [3 3] [4 4]]) |=([a=@ b=@] (add a b)))
::      5
++  average-by
  |*  [a=(list) b=$-(* @ud)]
  (div (roll (turn a b) add) (lent a))
::    +choose: [(list *) $-(* (unit *))] -> (list *)
::
::  Applies a function to each element in a list and then returns a list of
::  values v where the applied function returns (unit v). 
::  Returns an empty list when the input list is empty or when the applied
::  chooser function returns ~ for all elements.
::    Source
::      ++  murn
::        ~/  %murn
::        |*  [a=(list) b=$-(* (unit))]
::        =>  .(a (homo a))
::        |-  ^-  (list _?>(?=(^ a) (need (b i.a))))
::        ?~  a  ~
::        =/  c  (b i.a)
::        ?~  c  $(a t.a)
::        [+.c $(a t.a)]
::    Examples
::      > =a |=(a=@ ?.((gte a 2) ~ (some (add a 10))))
::      > (choose `(list @)`[0 1 2 3 ~] a)
::      [i=12 t=[i=13 t=~]]
++  choose  murn
::    +chunk-by-size: [(list *) chunkSize:@ud] -> (list (list *))
::
::  Divides the input list into lists (chunks) with a positive number of at
::  most chunkSize elements. Returns a new list containing the generated lists
::  (chunks) as its elements. Returns an empty list when the input list is empty
::    Source
::      ++  chunk-by-size
::        |*  [p=(list) q=@ud]
::        ?:  =(0 q)  ~|("non-zero size required" !!)
::        =/  res=(list (list _?>(?=(^ p) i.p)))  ~
::        =/  i=@ud  0
::        =/  next=(list _?>(?=(^ p) i.p))  ~
::        |-  ^-  (list (list _?>(?=(^ p) i.p)))
::        ?~  p  (flop [(flop next) res])
::        ?:  =(i q)  $(i 0, res [(flop next) res], next ~)
::        $(i +(i), next [i.p next], p t.p)
::    Examples
::      > (chunk-by-size (limo ~[1 2 3 4 5 6 7]) 2)
::      [i=~[1 2] t=[i=~[3 4] t=~[~[5 6] ~[7]]]]
++  chunk-by-size
  |*  [p=(list) q=@ud]
  ?:  =(0 q)  ~|("non-zero size required" !!)
  =/  res=(list (list _?>(?=(^ p) i.p)))  ~
  =/  i=@ud  0
  =/  next=(list _?>(?=(^ p) i.p))  ~
  |-  ^-  (list (list _?>(?=(^ p) i.p)))
  ?~  p  (flop [(flop next) res])
  ?:  =(i q)  $(i 0, res [(flop next) res], next ~)
  $(i +(i), next [i.p next], p t.p)
::    +collect: [(list) mapping:$-(* (list))] -> (list)
::
::  For each element of the list, applies the given function. Concatenates all
::  the results and return the combined list.
::    Source
::      ++  collect
::        |*  [p=(list) q=$-(* (list))]
::        =/  res=(list)  ~
::        |-
::        ?~  p  (flop res)
::        =/  c=(list)  (q i.p)
::        |-
 ::       ?~  c  ^$(p t.p)
::        $(c t.c, res [i.c res])
::    Examples
::      > (collect (limo ~[1 2 3]) |=(a=* (limo ~[a a])))
::      ~[1 1 2 2 3 3]
++  collect
  |*  [p=(list) q=$-(* (list))]
  =/  res=(list)  ~
  |-
  ?~  p  (flop res)
  =/  c=(list)  (q i.p)
  |-
  ?~  c  ^$(p t.p)
  $(c t.c, res [i.c res])
::    +compare: [(list) (list) comparer:$-([* *] ?)] -> (list ?)
::
::  Compares two lists element by element using the given comparison function.
::  When an entry exists for both lists, returns the result of the comparer 
::  function. When the second list is longer than the first returns %.y for
::  entries of second where first does not exist. When first list is longer
::  returns %.n for entries of first where second does not exist.
::    Source
::      ++  compare
::        |*  [b=(list) c=(list) a=$-([* *] ?)]
::        =/  res=(list ?)  ~
::        =/  bb  b
::        =/  cc  c
::        |-  ^-  (list ?)
::        ?~  bb  ?~  cc  (flop res)  $(cc t.cc, res [%.y res])
::        ?~  cc  $(bb t.bb, res [%.n res])
::        $(bb t.bb, cc t.cc, res [(a i.bb i.cc) res])
::    Examples
::      > (compare "when" "than" aor)
::      ~[%.n %.y %.n %.y]
++  compare
  |*  [b=(list) c=(list) a=$-([* *] ?)]
  =/  res=(list ?)  ~
  =/  bb  b
  =/  cc  c
  |-  ^-  (list ?)
  ?~  bb  ?~  cc  (flop res)  $(cc t.cc, res [%.y res])
  ?~  cc  $(bb t.bb, res [%.n res])
  $(bb t.bb, cc t.cc, res [(a i.bb i.cc) res])
::    +concat: (list (list)) -> (list)
::
::  Returns a new list that contains the elements of each of the lists in order.
::    Source
::      ++  zing
::        ~/  %zing
::        =|  *
::        |@
::        ++  $
::          ?~  +<
::            +<
::          (welp +<- $(+< +<+))
::        --
::    Examples
::      > (concat (limo [(limo ['a' 'b' 'c' ~]) (limo ['e' 'f' 'g' ~]) 
::          (limo ['h' 'i' 'j' ~]) ~]))
::      ~['a' 'b' 'c' 'e' 'f' 'g' 'h' 'i' 'j']
::      > (concat (limo [(limo [1 'a' 2 'b' ~]) (limo [3 'c' 4 'd' ~]) ~]))
::      ~[1 97 2 98 3 99 4 100]
++  concat  zing
::    +contains: [(list) value:*] -> ?
::
::  Tests if the list contains the specified element.
::    Source
::      ++  contains
::        |*  [p=(list) q=*]
::        |-  ^-  ?
::        ?~  p  %.n
::        ?:  =(q i.p)  %.y
::        $(p t.p)
::    Examples
::      > (contains "yep" `(list tape)`~["nope" "yep"])
::      %.y
++  contains
  |*  [p=(list) q=*]
  |-  ^-  ?
  ?~  p  %.n
  ?:  =(q i.p)  %.y
  $(p t.p)
::    +count-by: [(list) projection:$-(* *)] -> (list [* @ud])
::
::  Applies a key-generating function to each element of a list and returns a
::  list yielding unique keys and their number of occurrences in the original
::  list.
::    Source
::      ++  count-by
::        |*  [p=(list) q=$-(* *)]
::        =/  res=(map _?>(?=(^ p) (q i.p)) @ud)  ~
::        |-  ^-  (list [_?>(?=(^ p) (q i.p)) @ud])
::        ?~  p  ~(tap by res)
::        =/  key=_?>(?=(^ p) (q i.p))  (q i.p)
::        =/  val  (~(get by res) key)
::        ?~  val  $(res `(map _?>(?=(^ p) (q i.p)) @ud)`(~(put by res) key 1), p t.p)
::        $(res `(map _?>(?=(^ p) (q i.p)) @ud)`(~(put by res) key +(`@ud`(need val))), p t.p)
::    Examples
::      > (count-by:seq (limo ~["where" "when" "there" "then"]) |=(a=tape (first-n:seq 2 a)))
::      ~[[[i='t' t="h"] 2] [[i='w' t="h"] 2]]
++  count-by
  |*  [p=(list) q=$-(* *)]
  =/  res=(map _?>(?=(^ p) (q i.p)) @ud)  ~
  |-  ^-  (list [_?>(?=(^ p) (q i.p)) @ud])
  ?~  p  ~(tap by res)
  =/  key=_?>(?=(^ p) (q i.p))  (q i.p)
  =/  val  (~(get by res) key)
  ?~  val  $(res `(map _?>(?=(^ p) (q i.p)) @ud)`(~(put by res) key 1), p t.p)
  $(res `(map _?>(?=(^ p) (q i.p)) @ud)`(~(put by res) key +(`@ud`(need val))), p t.p)
::    +distinct: (list) -> (list)
::
::  Returns a list that contains no duplicate entries according to generic hash
::  and equality comparisons on the entries. If an element occurs multiple times
::  in the list then the later occurrences are discarded.
::    Source
::      ++  distinct
::        |*  a=(list)
::        =/  b=(list _?>(?=(^ a) i.a))  ~
::        =/  c=(set)  ~
::        |-  ^+  a
::        ?~  a  (flop b)
::        ?:  (~(has in c) i.a)  $(a t.a)
::        $(a t.a, b [i.a b], c (~(put in c) i.a))
::    Examples
::      > (distinct `(list tape)`~["tape1" "tape0" "tape1" "tape0"])
::      ~["tape1" "tape0"]
++  distinct
  |*  a=(list)
  =/  b=(list _?>(?=(^ a) i.a))  ~
  =/  c=(set)  ~
  |-  ^+  a
  ?~  a  (flop b)
  ?:  (~(has in c) i.a)  $(a t.a)
  $(a t.a, b [i.a b], c (~(put in c) i.a))
::    +distinct-by: [(list) projection:$-(* *)] -> (list)
::
::  Returns a list that contains no duplicate entries according to the generic
::  hash and equality comparisons on the keys returned by the given
::  key-generating function. If an element occurs multiple times in the list
::  then the later occurrences are discarded.
::    Source
::      ++  distinct-by
::        |*  [p=(list) q=$-(* *)]
::        =/  b=(list _?>(?=(^ p) i.p))  ~
::        =/  c=(set)  ~
::        |-  ^+  p
::        ?~  p  (flop b)
::        ?:  (~(has in c) (q i.p))  $(p t.p)
::        $(p t.p, b [i.p b], c (~(put in c) (q i.p)))
::    Examples
::      > =foo `(list [@ @])`~[[1 1] [1 2] [1 3] [2 1]]
::      > (distinct-by foo |=([a=@ b=@] (add a b)))
::      ~[[1 1] [1 2] [1 3]]
++  distinct-by
  |*  [p=(list) q=$-(* *)]
  =/  b=(list _?>(?=(^ p) i.p))  ~
  =/  c=(set)  ~
  |-  ^+  p
  ?~  p  (flop b)
  ?:  (~(has in c) (q i.p))  $(p t.p)
  $(p t.p, b [i.p b], c (~(put in c) (q i.p)))
::    +empty: $ -> *(list $)
::
::  Returns an empty list typed by the mold. (The bunt of the typed list.)
::    Source
::      ++  empty
::        |*  a=mold
::        *(list a)
::    Examples
++  empty
  |*  a=mold
  *(list a)
::    +exactly-one: (list) -> *
::
::  Returns the only element of the list. Crashes if list has different length.
::    Source
::      ++  exactly-one
::        |*  a=(list)
::        ?:  =(1 (lent a))  -.a
::        ~|("list does not have only one element" !!)
::    Examples
::      > (exactly-one (limo ~["tape"]))
::      "tape"
++  exactly-one
  |*  a=(list)
  ?:  =(1 (lent a))  -.a
  ~|("list does not have only one element" !!)
::    +except: [(list) items-to-exclude:(list)] -> (list)
::
::  Returns a new list with the distinct elements of the input list which do not
::  appear in the items-to-exclude list, using generic hash and equality
::  comparisons to compare values.
::    Source
::      ++  except
::        |*  [p=(list) q=(list)]
::        =/  qq  (silt q)
::        =/  b=(list _?>(?=(^ p) i.p))  ~
::        |-  ^+  p
::        ?~  p  (flop b)
::       ?:  (~(has in qq) i.p)  $(p t.p)
::        $(p t.p, b [i.p b], qq (~(put in qq) i.p))
::    Examples
::      > (except (limo ~["able" "baker" "charlie" "dog"]) (limo ~["baker" "dog"]))
::      ~[[i='a' t="ble"] [i='c' t="harlie"]]
++  except
  |*  [p=(list) q=(list)]
  =/  qq  (silt q)
  =/  b=(list _?>(?=(^ p) i.p))  ~
  |-  ^+  p
  ?~  p  (flop b)
  ?:  (~(has in qq) i.p)  $(p t.p)
  $(p t.p, b [i.p b], qq (~(put in qq) i.p))
::    +exists: [(list) predicate:$-(* ?)] -> ?
::
::  Tests if any element of the list satisfies the given predicate.
::    Source
::      ++  exists
::        |*  [a=(list) b=$-(* ?)]
::        |-  ^-  ?
::        ?~  a  %.n
::        ?:  (b i.a)  %.y
::        $(a t.a)
::    Examples
::      > =foo |=  a=tape
::        ?:  ?&(=(4 (lent a)) =('a' -.a))  %.y  %.n
::      > (exists:seq (limo ~["aaa" "able" "baker" "charlie" "dog"]) foo)
::      %.y
++  exists
  |*  [a=(list) b=$-(* ?)]
  |-  ^-  ?
  ?~  a  %.n
  ?:  (b i.a)  %.y
  $(a t.a)
::    +exists2: [(list1) (list2) predicate:$-(* ?)] -> ?
::
::  Tests if any pair of corresponding elements of the lists satisfies the given
::  predicate.
::    Source
::      ++  exists2
::        |*  [a=(list) b=(list) c=$-([* *] ?)]
::        |-  ^-  ?
::        ?~  a  %.n
::        ?~  b  %.n
::        ?:  (c [i.a i.b])  %.y
::        $(a t.a, b t.b)
::    Examples
::      > =foo |=  [a=tape b=tape]
::        ?:  =(-.a -.b)  %.y  %.n
::      > (exists2 (limo ~["cat" "betty"]) (limo ~["able" "butter"]) foo)
::      %.y
++  exists2
  |*  [a=(list) b=(list) c=$-([* *] ?)]
  |-  ^-  ?
  ?~  a  %.n
  ?~  b  %.n
  ?:  (c [i.a i.b])  %.y
  $(a t.a, b t.b)
::    +filter: [(list) predicate:$-(* ?)] -> (list)
::
::  Returns a new collection containing only the elements of the collection for
::  which the given predicate returns "true"
::    Source
::      ++  skim
::        ~/  %skim
::        |*  [a=(list) b=$-(* ?)]
::        |-
::        ^+  a
::        ?~  a  ~
::       ?:((b i.a) [i.a $(a t.a)] $(a t.a))
::    Examples
::      > =a |=(a=@ (gth a 1))
::      > (filter `(list @)`[0 1 2 3 ~] a)
::      [i=2 t=~[3]]
++  filter  skim
::    +first-n: [(list *) count:@ud] -> (list *)
::
::  Returns the first N elements of the list.
::    Source
::      ++  first-n
::        |*  [p=(list) q=@]
::        (scag q p)
::    Examples
::      > (first-n `(list @)`[1 2 3 4 ~] 2)
::      [i=1 t=~[2]]
::      > (first-n `(list @)`[1 2 3 4 ~] 10)
::      [i=1 t=~[2 3 4]]
++  first-n
  |*  [p=(list) q=@]
  (scag q p)
::    +fold: [(list) state:* folder:$-([* *] *)] -> * 
::
::  Applies a function to each element of the collection, threading an
::  accumulator argument through the computation. Take the second argument, and
::  apply the function to it and the first element of the list. Then feed this
::  result into the function along with the second element and so on. Return the
::  final result. If the input function is f and the elements are i0...iN then
::  computes f (... (f s i0) i1 ...) iN.
::    Source
::      ++  fold
::        |*  [a=(list) b=* c=_|=(^ [** +<+])]
::        |-  ^-  _b
::        ?~  a  b
::        $(a t.a, b (c i.a b))
::    Examples
::      > (fold (gulf 1 5) 0 |=([n=@ state=@] (add state (mul n n))))
::      55
++  fold
  |*  [a=(list) b=* c=_|=(^ [** +<+])]
  |-  ^-  _b
  ?~  a  b
  $(a t.a, b (c i.a b))
::    +fold2: [(list) (list) state:* folder:$-([* * *] *)] -> *
::
::  Applies a function to corresponding elements of two collections, threading
::  an accumulator argument through the computation. The collections must have
::  identical sizes. If the input function is f and the elements are i0...iN and
::  j0...jN then computes f (... (f s i0 j0)...) iN jN.
::    Source
::      ++  fold2
::        |*  [a=(list) b=(list) c=* d=_|=(^ [** ** +<+])]
::        |-  ^-  _c
::        ?~  a  ?~  b  c  ~|("lists are not same length" !!)
::        ?~  b  ~|("lists are not same length" !!)
::        $(a t.a, b t.b, c (d i.a i.b c))
::    Examples
::      > (fold2 (limo ~["Tails" "Head" "Tails"]) (limo ~["Tails" "Head" "Head"]) 0 |=([n1=tape n2=tape state=@] ?:(=(n1 n2) +(state) state)))
::      2
++  fold2
  |*  [a=(list) b=(list) c=* d=_|=(^ [** ** +<+])]
  |-  ^-  _c
  ?~  a  ?~  b  c  ~|("lists of unequal length" !!)
  ?~  b  ~|("lists of unequal length" !!)
  $(a t.a, b t.b, c (d i.a i.b c))
::    +fold-back: [(list) state:* folder:$-([* *] *)] -> *
::
::  Applies a function to each element of the collection, starting from the end,
::  threading an accumulator argument through the computation. If the input
::  function is f and the elements are i0...iN then computes f i0 (...(f iN s)).
::    Source
::      ++  fold-back
::        |*  [a=(list) b=* c=$-([* *] *)]
::        (fold (flop a) b c)
::    Examples
::      > =less-hungry |=  [n=tape state=(list [tape @])]
::          ^+  state
::          ?~  state  (limo ~[[n 1]])
::          [[n +(+.i.state)] state]
::      > (fold-back:seq (limo ~["Apple" "Pear" "Orange"]) `(list [tape @])`~ less-hungry)
::      [i=["Apple" 3] t=~[["Pear" 2] ["Orange" 1]]]
++  fold-back
  |*  [a=(list) b=* c=$-([* *] *)]
  (fold (flop a) b c)
::    +fold-back2: [(list) (list) state:* folder:$-([* * *] *)] -> *
::
::  Applies a function to corresponding elements of two collections, threading
::  an accumulator argument through the computation. The collections must have
::  identical sizes. If the input function is f and the elements are i0...iN and
::  j0...jN then computes f i0 j0 (...(f iN jN s)).
::    Source
::      ++  fold-back2
::        |*  [a=(list) b=(list) c=* d=$-([* * *] *)]
::        (fold2 (flop a) (flop b) c d)
::    Examples
::      > (fold-back2 (limo ~["Tails" "Head" "Tails"]) (limo ~["Tails" "Head" "Head"]) `(list tape)`~ |=([n1=tape n2=tape state=(list tape)] [(weld n1 n2) state]))
::      ~["TailsTails" "HeadHead" "TailsHead"]
++  fold-back2
  |*  [a=(list) b=(list) c=* d=$-([* * *] *)]
  (fold2 (flop a) (flop b) c d)
::    +forall: [(list) predicate:$-(* ?)] -> ?
::
::  Tests if all elements of the collection satisfy the given predicate.
::    Source
::      ++  forall
::        |*  [a=(list) predicate=$-(* ?)]
::        |-  ^-  ?
::        ?~  a  %.y
::        ?.  (predicate i.a)  %.n
::        $(a t.a)
::    Examples
::      > (forall (limo ~[2 4 8]) |=(a=@ ?:(=(0 (mod a 2)) %.y %.n)))
::      %.y
::      > (forall:seq (limo ~[2 1 8]) |=(a=@ ?:(=(0 (mod a 2)) %.y %.n)))
::      %.n
++  forall
  |*  [a=(list) predicate=$-(* ?)]
  |-  ^-  ?
  ?~  a  %.y
  ?.  (predicate i.a)  %.n
  $(a t.a)
::    +forall2: [(list) (list) predicate:$-([* *] ?)] -> ?
::
::  Tests if all corresponding elements of the collection satisfy the given
::  predicate pairwise.
::    Source
::    Examples
::      > (forall (limo ~[1 4 8]) (limo ~[3 4 8]) |=([a=@ b=@] ?:(=(0 (mod (add a b) 2)) %.y %.n)))
::      %.y
::    Examples
::      > (forall (limo ~[1 5 8]) (limo ~[3 4 8]) |=([a=@ b=@] ?:(=(0 (mod (add a b) 2)) %.y %.n)))
::      %.y
++  forall2
  |*  [a=(list) b=(list) predicate=$-(* ?)]
  ?.  =((lent a) (lent b))  ~|("lists of unequal length" !!)
  |-  ^-  ?
  ?~  a  %.y
  ?~  b  ~|("can't get here" !!)
  ?.  (predicate i.a i.b)  %.n
  $(a t.a, b t.b)
::    +get-head: (list) -> *
::
::  Returns the first element of the list. Crashes on empty list.
::    Source
::      ++  get-head
::        |*  a=(list)
::        ?~  a  ~|("not found" !!)
::        i.a
::    Examples
::      > (get-head ~[1 2])
::      1
++  get-head
  |*  a=(list)
  ?~  a  ~|("empty list" !!)
  i.a
::    +get-tail: (list) -> (list)
::
::  Returns the list after removing the first element.
::    Source
::    Examples
::      > (get-tail ~[1 2])
::      ~[2]
++  get-tail
  |*  a=(list)
  ?~  a  ~|("empty list" !!)
  t.a
::

::
::    +group-by: projection list
::
::  Applies a key-generating function to each element of a list and yields a
::  list of unique keys. Each unique key contains a list of all elements that
::  match to this key.
::    Source
::    Examples
++  group-by  !!
::

::    +indexed: list
::
::  Returns a new list whose elements are the corresponding elements of the
::  input list paired with the index (from 0) of each element.
::    Source
::    Examples
++  indexed  !!
::

::    +init: length initializer
::
::  Creates a list by calling the given generator on each index.
::    Source
::    Examples
++  init  !!
::

::    +insert-at: [(list) index:@ value:*] -> (list)
::
::  Return a new list with a new item inserted before the given index.
::    Source
::      ++  into
::        ~/  %into
::        |*  [a=(list) b=@ c=*]
::        ^+  a
::        (weld (scag b a) [c (slag b a)])
::    Examples
::    > (insert-at (limo ~[2 3 4]) 1 11)
::    ~[2 11 3 4]
++  insert-at  into
::    +insertManyAt: [(list) values=(list) index=@] -> (list)
::
::  Return a new list with new items inserted before the given index.
::    Source
::    Examples
++  insert-many-at  !!
::

::    +is-empty: (list) -> ?
::
::  Returns true if the list contains no elements, false otherwise.
::    Source
::    Examples
::      > (is-empty `(list @)`~[2])
::      %.n
::      > (is-empty `(list @)`~)
::      %.y
++  is-empty
  |*  a=(list)
  ?~  a  %.y  %.n
::

::    +item: index list
::
::  Indexes into the list. The first element has index 0.
::    Source
::    Examples
++  item  !!
::

::    +last-n: [(list *) count:@ud] -> (list *)
::
::  Returns the last N elements of the list.
::    Source
::      ++  last-n
::        |*  [p=(list) q=@]
::        (flop (scag q (flop p)))
::    Examples
::      > (last-n `(list @)`[1 2 3 4 ~] 2)
::      [i=3 t=~[4]]
::      > (last-n `(list @)`[1 2 3 4 ~] 10)
::      [i=1 t=~[2 3 4]]
++  last-n
  |*  [p=(list) q=@]
  (flop (scag q (flop p)))
::    +length: (list *) -> @ud
::
::  Returns the length of the list.
::    Source
::      ++  lent
::        ~/  %lent
::        |=  a=(list)
::        ^-  @
::        =+  b=0
::        |-
::        ?~  a  b
::        $(a t.a, b +(b))
::    Examples
::      > (length [1 2 3 4 ~])
::      4
::      > (length [1 'a' 2 'b' (some 10) ~])
::      5
++  length  lent
::    +map-items: [(list) mapping:$-(* *)] -> (list)
::
::  Builds a new list whose elements are the results of applying the given
::  gate to each of the elements of the list.
::    Source
::      ++  turn
::        ~/  %turn
::        |*  [a=(list) b=gate]
::        =>  .(a (homo a))
::        ^-  (list _?>(?=(^ a) (b i.a)))
::        |-
::        ?~  a  ~
::        [i=(b i.a) t=$(a t.a)]
::    Examples
::      > (map (limo [104 111 111 110 ~]) @t)
::      <|h o o n|>
::      > =a |=(a=@ (add a 4))
::      > (map (limo [1 2 3 4 ~]) a)
::      ~[5 6 7 8]
++  map-items  turn
::

::    +map2: [(list1) (list2) mapping
::
::  Builds a new collection whose elements are the results of applying the given
::  function to the corresponding elements of the two collections pairwise.
::    Source
::    Examples
++  map2  !!
::

::    +map3: [(list) (list) (list) mapping
::
::  Builds a new collection whose elements are the results of applying the given
::  function to the corresponding elements of the three collections
::  simultaneously.
::    Source
::    Examples
++  map3  !!
::

::    +map-fold: [(list) state mapping
::
::  Combines map and fold. Builds a new list whose elements are the results of
::  applying the given function to each of the elements of the input list. The
::  function is also used to accumulate a final value.
::    Source
::    Examples
++  map-fold  !!
::

::    +map-fold-back: [(list) state mapping
::
::  Combines map and foldBack. Builds a new list whose elements are the results
::  of applying the given function to each of the elements of the input list.
::  The function is also used to accumulate a final value.
::    Source
::    Examples
++  map-fold-back  !!
::

::    +mapi: [(list) mapping
::
::  Builds a new collection whose elements are the results of applying the given
::  function to each of the elements of the collection. The integer index passed
::  to the function indicates the index (from 0) of element being transformed.
::    Source
::    Examples
++  mapi  !!
::

::    +mapi2: [(list) (list) mapping 
::
::  Like mapi, but mapping corresponding elements from two lists of equal length.
::    Source
::    Examples
++  mapi2  !!
::

::    +max: (list) -> *
::
::  Return the greatest of all elements of the list, compared via Operators.max.
::    Source
::    Examples
++  max  !!
::

::    +maxBy: (list) projection
::
::  Returns the greatest of all elements of the list, compared via Operators.max
::  on the function result.
::    Source
::    Examples
++  max-by  !!
::

::    +min: (list) 
::
::  Returns the lowest of all elements of the list, compared via Operators.min.
::    Source
::    Examples
++  min  !!
::

::    +minBy: (list) projection
::
::  Returns the lowest of all elements of the list, compared via Operators.min
::  on the function result
::    Source
::    Examples
++  min-by  !!

::    +pairwise: (list 'T) -> (list ['T 'T]) 
::
::  Returns a list of each element in the input list and its predecessor, with
::  the exception of the first element which is only returned as the predecessor
::  of the second element.
::    Source
::    Examples
++  pairwise  !!
::

::    +partition: [(list) predicate:$-(* ?)] -> [(list) (list)]
::
::  Splits the collection into two collections, containing the elements for
::  which the given predicate returns True and False respectively. Element order
::  is preserved in both of the created lists.
::    Source
::      ++  skid
::        ~/  %skid
::        |*  [a=(list) b=$-(* ?)]
::        |-  ^+  [p=a q=a]
::        ?~  a  [~ ~]
::        =+  c=$(a t.a)
::        ?:((b i.a) [[i.a p.c] q.c] [p.c [i.a q.c]])
::    Examples
::      > =a |=(a=@ (gth a 1))
::      > (partition `(list @)`[0 1 2 3 ~] a)
::      [p=[i=2 t=~[3]] q=[i=0 t=~[1]]]
++  partition  skid
::

::    +permute: list
::
::  Returns a list with all elements permuted according to the specified 
::  permutation.
::    Source
::    Examples
++  permute  !!
::

::    +pick: [(list) chooser
::
::  Applies the given function to successive elements, returning the first
::  result where function returns Some(x) for some x. If no such element exists
::  then raise KeyNotFoundException
::    Source
::    Examples
++  pick  !!
::

::    +reduce: [(list) reduction 
::
::  Apply a function to each element of the collection, threading an accumulator
::  argument through the computation. Apply the function to the first two
::  elements of the list. Then feed this result into the function along with the
::  third element and so on. Return the final result. If the input function is f
::  and the elements are i0...iN then computes f (... (f i0 i1) i2 ...) iN.
::    Source
::    Examples
++  reduce  !!
::

::    +reduceBack: [(list) reduction 
::
::  Applies a function to each element of the collection, starting from the end,
::  threading an accumulator argument through the computation. If the input
::  function is f and the elements are i0...iN then computes 
::  f i0 (...(f iN-1 iN)).
::    Source
::    Examples
++  reduce-back  !!
::

::    +remove-at: [(list) index:@] -> (list)
::
::  Return a new list with the item at a given index removed.
::    Source
::    Examples
++  remove-at  !!
::

::    +remove-many-at: [(list) index=@ count=@] -> (list)
::
::  Return a new list with the number of items starting at a given index removed
::    Source
::      ++  remove-many-at
::        |*  [a=(list) b=@ c=@]
::        (oust [b c] a)
::    Examples
::      > (remove-many-at "good day, urbit!" [4 5])
::      "good urbit!"
::      > (remove-many-at `(list @)`[1 2 3 4 ~] [2 2])
::      ~[1 2]
++  remove-many-at
  |*  [a=(list) b=@ c=@]
  (oust [b c] a)
::    +replicate: [count=@ initial=*] -> (list *)
::
::  Creates a list by replicating the given initial value.
::    Source
::      ++  reap
::        ~/  %reap
::        |*  [a=@ b=*]
::        |-  ^-  (list _b)
::        ?~  a  ~
::        [b $(a (dec a))]
::    Examples
::      > (replicate 20 %a)
::      ~[%a %a %a %a %a %a %a %a %a %a %a %a %a %a %a %a %a %a %a %a]
::      > (replicate 5 ~s1)
::      ~[~s1 ~s1 ~s1 ~s1 ~s1]
::      > `@dr`(roll (replicate 5 ~s1) add)
::      ~s5
++  replicate  reap
::    +reverse: (list) -> (list)
::
::  Returns a new list with the elements in reverse order.
::    Source
::      ++  flop
::        ~/  %flop
::        |*  a=(list)
::        =>  .(a (homo a))
::        ^+  a
::        =+  b=`_a`~
::        |-
::        ?~  a  b
::        $(a t.a, b [i.a b])
::    Examples
::      > =a [1 2 3 ~]
::      > (flop a)
::      ~[3 2 1]
::      > (flop (flop a))
::      ~[1 2 3]
++  reverse  flop
::    +scan: [(list) state folder
::
::  Applies a function to each element of the collection, threading an
::  accumulator argument through the computation. Take the second argument, and
::  apply the function to it and the first element of the list. Then feed this
::  result into the function along with the second element and so on. Returns
::  the list of intermediate results and the final result.
::    Source
::    Examples
++  scan  !!
::

::    +scan-back: [(list) state folder
::
::  Like fold-back, but returns both the intermediary and final results
::    Source
::    Examples
++  scan-back  !!

::
::    +search: [(list) predicate:$-(* ?)] -> *
::
::  Returns the first element for which the given function returns True. 
::  Crashes if no such element exists.
::    Source
::      ++  search
::        |*  [a=(list) b=$-(* ?)]
::        |-  ^-  _?>(?=(^ a) i.a)
::        ?~  a  ~|("not found" !!)
::        ?:  (b i.a)  i.a  $(a t.a)
::    Examples
::      > (search (gulf [1 30]) |=(a=@ud ?&(=(0 (mod a 3)) =(0 (mod a 5)))))
::      15
++  search
  |*  [a=(list) b=$-(* ?)]
  |-  ^-  _?>(?=(^ a) i.a)
  ?~  a  ~|("not found" !!)
  ?:  (b i.a)  i.a  $(a t.a)
::    +search-all: [(list) predicate:$-(* ?)] -> (list))
::
::  Returns all elements for which the given function returns True. 
::  Crashes if no such element exists.
::    Source
::      ++  search-all
::        |*  [a=(list) b=$-(* ?)]
::        =/  c=(list _?>(?=(^ a) i.a))  ~
::        |-
::        ?~  a  ?~  c  ~|("not found" !!)  (flop c)
::        ?:  (b i.a)  $(a t.a, c [i.a c])  $(a t.a)
::    Examples
::      > (search-all (gulf [1 30]) |=(a=@ud ?&(=(0 (mod a 3)) =(0 (mod a 5)))))
::      ~[15 30]
++  search-all
  |*  [a=(list) b=$-(* ?)]
  =/  c=(list _?>(?=(^ a) i.a))  ~
  |-
  ?~  a  ?~  c  ~|("not found" !!)  (flop c)
  ?:  (b i.a)  $(a t.a, c [i.a c])  $(a t.a)
::    +search-all-by-list: [(list) arg:(list) -> (list @)]
::
::  Produces list of indices of all occurrences of the argument list sequence in
::  the sequence of the source list.
::    Source
::      ++  search-all-by-list
::        |*  [hstk=(list) nedl=(list)]
::        ^-  (list @)
::        (fand nedl hstk)
::    Examples
::      > (search-all-by-list "cbabab" "ba")
::      ~[1 3]
++  search-all-by-list
  |*  [hstk=(list) nedl=(list)]
  ^-  (list @)
  (fand nedl hstk)
::    +search-back: [(list) predicate:$-(* ?)] -> *
::
::  Returns the last element for which the given function returns True. 
::  Crashes if no such element exists.
::    Source
::      ++  search-back
::        |*  [a=(list) b=$-(* ?)]
::        ?~  a  ~|("not found" !!)
::        (search (flop a) b)
::    Examples
::      > (search-back (gulf [1 30]) |=(a=@ud ?&(=(0 (mod a 3)) =(0 (mod a 5)))))
::      30
++  search-back
  |*  [a=(list) b=$-(* ?)]
  ?~  a  ~|("not found" !!)
  (search (flop a) b)
::    +search-back-by-list: [(list) arg:(list)] -> @ud
::
::  Produces the index of the last occurrence of the argument list sequence in
::  the sequence of the source list.
::    Source
::      ++  search-back-by-list
::        |*  [hstk=(list) nedl=(list)]
::        (tail-end (search-all-by-list hstk nedl))
::    Examples
::      > (search-back-by-list "cbabab" "ba")
::      3
++  search-back-by-list
  |*  [hstk=(list) nedl=(list)]
  (tail-end (search-all-by-list hstk nedl))
::    +search-by-list: [(list) arg:(list)] -> @ud
::
::  Produces the index of the first occurrence of the argument list sequence in
::  the sequence of the source list.
::    Source
::      ++  search-by-list
::        |*  [hstk=(list) nedl=(list)]
::        ^-  @
::        =/  x  (find nedl hstk)
::        ?~  x  ~|("not found" !!)  (need x)
::    Examples
::      > (search-by-list "cbabab" "ab")
::      2
++  search-by-list
  |*  [hstk=(list) nedl=(list)]
  ^-  @
  =/  x  (find nedl hstk)
  ?~  x  ~|("not found" !!)  (need x)
::    +search-index: [(list) predicate:$-(* ?)] -> @ud
::
::  Returns the index of the first element in the list that satisfies the given
::  predicate. Crashes if no such element exists.
::    Source
::      ++  search-index
::        |*  [a=(list) b=$-(* ?)]
::        =/  i  0
::        |-  ^-  @ud
::        ?~  a  ~|("not found" !!)
::        ?:  (b i.a)  i  $(a t.a, i +(i))
::    Examples
::      > (search-index (gulf [1 30]) |=(a=@ud ?&(=(0 (mod a 3)) =(0 (mod a 5)))))
::      14
++  search-index
  |*  [a=(list) b=$-(* ?)]
  =/  i  0
  |-  ^-  @
  ?~  a  ~|("not found" !!)
  ?:  (b i.a)  i  $(a t.a, i +(i))
::    +search-index-all: [(list) predicate:$-(* ?)] -> (list @)
::
::  Returns the list of indices in the list that satisfies the given predicate.
::    Source
::      ++  search-index-all
::        |*  [a=(list) b=$-(* ?)]
::        =/  c=(list @)  ~
::        =/  i  0
::        |-  ^-  (list @)
::        ?~  a  (flop c)
::        ?:  (b i.a)  $(a t.a, c [i c], i +(i))  $(a t.a, i +(i))
::    Examples
::      > (search-index-all (gulf [1 30]) |=(a=@ud ?&(=(0 (mod a 3)) =(0 (mod a 5)))))
::      ~[14 29]
++  search-index-all
  |*  [a=(list) b=$-(* ?)]
  =/  c=(list @)  ~
  =/  i  0
  |-  ^-  (list @)
  ?~  a  (flop c)
  ?:  (b i.a)  $(a t.a, c [i c], i +(i))  $(a t.a, i +(i))
::    +search-index-back: [(list) predicate:$-(* ?)] -> @ud
::
::  Returns the index of the last element in the list that satisfies the given
::  predicate. Crashes if no such element exists.
::    Source
::      ++  search-index-back
::        |*  [a=(list) c=$-(* ?)]
::        ?~  a  ~|("not found" !!)
::        =/  b  (flop a)
::        =/  i  (dec (lent a))
::        |-  ^-  @ud
::        ?~  b  ~|("not found" !!)
::        ?:  (c i.b)  i  $(b t.b, i (dec i))
::    Examples
::      > (search-index-back (gulf [1 30]) |=(a=@ud ?&(=(0 (mod a 3)) =(0 (mod a 5)))))
::      29
++  search-index-back
  |*  [a=(list) c=$-(* ?)]
  ?~  a  ~|("not found" !!)
  =/  b  (flop a)
  =/  i  (dec (lent a))
  |-  ^-  @ud
  ?~  b  ~|("not found" !!)
  ?:  (c i.b)  i  
  ?:  =(0 i)  ~|("not found" !!)
  $(b t.b, i (dec i))
::    +singleton: value: * -> (list)
::
::  Returns a list that contains one item only.
::    Source
::    Examples
::      > (singleton "tape")
::      ~["tape"]
++  singleton
  |*  a=*
  (limo ~[a])
::

::    +skip-n: [(list) count:@] -> (list)
::
::  Returns the list after removing the first N elements.
::    Source
::    Examples
++  skip-n  !!
::

::    +skip-while: [(list) predicate:$-(* ?)] -> (list)
::
::  Bypasses elements in a list while the given predicate returns True, and then
::  returns the remaining elements of the list.
::    Source
::    Examples
++  skip-while  !!
::

::    +sort: (list) -> (list)
::
::  Sorts the given list using Operators.compare.
::    Source
::    Examples
++  sort  !!
::

::    +sort-by: [(list) projection:] -> (list)
::
::  Sorts the given list using keys given by the given projection. Keys are
::  compared using Operators.compare.
::    Source
::    Examples
++  sort-by  !!
::

::    +sort-by-descending: [(list) projection:] -> (list)
::
::  Sorts the given list in descending order using keys given by the given
::  projection. Keys are compared using Operators.compare.
::    Source
::    Examples
++  sort-by-descending  !!
::

::    +sort-descending: (list) -> (list)
::
::  Sorts the given list in descending order using Operators.compare.
::    Source
::    Examples
++  sort-descending  !!
::

::    +sort-with: [(list) comparer:] -> (list)
::
::  Sorts the given list using the given comparison function.
::    Source
::    Examples
++  sort-with  !!
::

::    +split-at: [(list) index:@] -> [(list) (list)]
::
::  Splits a list into two lists, at the given index.
::    Source
::    Examples
++  split-at  !!
::

::    +split-into: [(list) count:@] -> (list (list))
::
::  Splits the input list into at most count chunks.
::    Source
::    Examples
++  split-into  !!
::

::    +sum: (list @) -> @
::
::  Returns the sum of the elements in the list.
::    Source
::    Examples
++  sum  !!
::

::    +sum-by: [(list @) projection 
::
::  Returns the sum of the results generated by applying the function to each
::  element of the list.
::    Source
::    Examples
++  sum-by  !!
::

::    +tail-end: (list) -> *
::
::  Returns the last element of the list.
::    ArgumentException:  Crash when the input does not have any elements.
::    Source
::      ++  tail-end
::        |*  a=(list)
::        ?~  a  ~|("not found" !!)
::        (rear a)
::    Examples
::      > (last ~[1 2 3])
::      3
::      > (last ~)
::      hoon expression failed
++  tail-end
  |*  a=(list)
  ?~  a  ~|("not found" !!)
  (rear a)
::    +take-while: [(list) predicate:$-(* ?)] -> (list)
::
::  Returns a list that contains all elements of the original list while the
::  given predicate returns True, and then returns no further elements.
::    Source
::    Examples
++  take-while  !!
::

::    +transpose: lists
::
::  Returns the transpose of the given sequence of lists.
::    Source
::    Examples
++  transpose  !!
::

::    +try-exactly-one: (list) -> (unit *)
::
::  Returns the only element of the list or None if it is empty or contains more
::  than one element.
::    Source
::      ++  try-exactly-one
::        |*  a=(list)
::        ?:  =(1 (lent a))  `-.a
::        ~
::    Examples
::      > (try-exactly-one (limo ~["tape"]))
::      [~ i=[i='t' t="ape"]]
++  try-exactly-one
  |*  a=(list)
  ?:  =(1 (lent a))  `-.a
  ~
::    +try-head: (list) -> (unit *)
::
::  Returns the first element of the list, or None if the list is empty.
::    Source
::      ++  try-head
::        |*  a=(list)
::        ?~  a  ~
::        `i.a
::    Examples
::      > (try-head ~[1 2])
::      `1
++  try-head
  |*  a=(list)
  ?~  a  ~
  `i.a

::    +try-item: [(list) index:@] -> (unit *)
::
::  Tries to find the nth element in the list. Returns None if index is negative
::  or the list does not contain enough elements.
::    Source
::    Examples
++  try-item  !!
::

::    +try-pick: [(list) chooser:$-(* (unit *))] -> (unit *)
::
::  Applies the given function to successive elements, returning Some(x) the
::  first result where function returns Some(x) for some x.
::  If no such element exists then return None.
::    Source
::    Examples
++  try-pick  !!
::

::    +try-search: [(list) predicate:$-(* ?)] -> (unit *)
::
::  Returns the first element for which the given function returns True.
::  Return None if no such element exists.
::    Source
::      ++  try-search
::        |*  [a=(list) b=$-(* ?)]
::        |-  ^-  (unit _?>(?=(^ a) i.a))
::        ?~  a  ~
::        ?:  (b i.a)  `i.a  $(a t.a)
::    Examples
::      > (try-search (gulf [1 30]) |=(a=@ud ?&(=(0 (mod a 3)) =(0 (mod a 5)))))
::      `15
++  try-search
  |*  [a=(list) b=$-(* ?)]
  |-  ^-  (unit _?>(?=(^ a) i.a))
  ?~  a  ~
  ?:  (b i.a)  `i.a  $(a t.a)
::    +try-search-back: [(list) predicate:$-(* ?)] -> (unit *)
::
::  Returns the last element for which the given function returns True.
::  Return None if no such element exists.
::    Source
::      ++  try-search-back
::        |*  [a=(list) b=$-(* ?)]
::        ?~  a  ~
::        (try-search (flop a) b)
::    Examples
::      > (try-search-back (gulf [1 30]) |=(a=@ud ?&(=(0 (mod a 3)) =(0 (mod a 5)))))
::      `30
++  try-search-back
  |*  [a=(list) b=$-(* ?)]
  ?~  a  ~
  (try-search (flop a) b)
::    +try-search-index: [(list) predicate:$-(* ?)] -> (unit @)
::
::  Returns the index of the first element in the list that satisfies the given
::  predicate. Return None if no such element exists.
::    Source
::      ++  try-search-index
::        |*  [a=(list) b=$-(* ?)]
::        =/  i  0
::        |-  ^-  (unit @)
::        ?~  a  ~
::        ?:  (b i.a)  `i  $(a t.a, i +(i))
::    Examples
::      > (try-search-index (gulf [1 30]) |=(a=@ud ?&(=(0 (mod a 3)) =(0 (mod a 5)))))
::      `14
++  try-search-index
  |*  [a=(list) b=$-(* ?)]
  =/  i  0
  |-  ^-  (unit @)
  ?~  a  ~
  ?:  (b i.a)  `i  $(a t.a, i +(i))
::    +try-search-index-back: [(list) predicate:$-(* ?)] -> (unit @ud)
::
::  Returns the index of the last element in the list that satisfies the given
::  predicate. Return None if no such element exists.
::    Source
::    Examples
++  try-search-index-back
  |*  [a=(list) c=$-(* ?)]
  ?~  a  ~
  =/  b  (flop a)
  =/  i  (dec (lent a))
  |-  ^-  (unit @ud)
  ?~  b  ~
  ?:  (c i.b)  `i  
  ?:  =(0 i)  ~
  $(b t.b, i (dec i))
::    +try-tail: (list) -> (unit (list))
::
::  Returns the elements of the list after the first, or None if the list is empty.
::    Source
::      ++  try-tail
::        |*  a=(list)
::        ?~  a  ~
::        `t.a
::    Examples
::      > (try-tail ~[1 2])
::      `~[2]
++  try-tail
  |*  a=(list)
  ?~  a  ~
  `t.a
::    +try-tail-end: (list) -> (unit *)
::
::  Returns the last element of the list. Return None if no such element exists.
::    Source
::      ++  try-tail-end
::        |*  a=(list)
::        ?~  a  ~
::        `(rear a)
::    Examples
++  try-tail-end
  |*  a=(list)
  ?~  a  ~
  `(rear a)
::

::    +unfold: state generator
::
::  Returns a list that contains the elements generated by the given computation
::  The generator is repeatedly called to build the list until it returns None.
::  The given initial state argument is passed to the element generator.
::    Source
::    Examples
++  unfold  !!
::

::    +unzip: (list ['T1 'T2]) - [(list 'T1) (list 'T2)]
::
::  Splits a list of pairs into two lists.
::    Source
::      ++  unzip
::        |*  a=(list [* *])
::        =/  b=(list *)  ~
::        =/  c=(list *)  ~
::        |-  ::^-  [_b _c]
::        ?~  a  [(flop b) (flop c)]
::        $(a t.a, b [-.i.a b], c [+.i.a c])
::    Examples
::      > (unzip (limo ~[[1 "aa"] [2 "bb"]]))
::      [~[1 2] ~["aa" "bb"]]
++  unzip
  |*  a=(list [* *])
  =/  b=(list *)  ~
  =/  c=(list *)  ~
::  =/  b=(list _?>(?=(^ -.a) -.i.a))  ~
::  =/  c=(list _?>(?=(^ +.a) +.i.a))  ~
::  =/  b=(list _-.i.a)  ~
::  =/  c=(list _+.i.a)  ~
  |-  ::^-  [_b _c]
  ?~  a  [(flop b) (flop c)]
  $(a t.a, b [-.i.a b], c [+.i.a c])
::    +unzip3: list
::
::  Splits a list of triples into three lists.
::    Source
::    Examples
::      > (unzip3 (limo ~[[1 "aa" 'a'] [2 "bb" 'b']]))
::      [~[1 2] ~["aa" "bb"] ~['a' 'b']]
++  unzip3
  |*  a=(list [* *])
  =/  b=(list *)  ~
  =/  c=(list *)  ~
  =/  d=(list *)  ~
  |-
  ?~  a  [(flop b) (flop c) (flop d)]
  $(a t.a, b [-.i.a b], c [+<.i.a c], d [+>.i.a d])

::    +update-at: index value source
::
::  Return a new list with the item at a given index set to the new value.
::    Source
::    Examples
++  update-at  !!
::

::    +where: [(list) predicate:$-(* ?)] -> (list)
::
::  Returns a new list containing only the elements of the list for which the
::  given predicate returns "true"
::    Source
::      ++  where
::        |*  [a=(list) predicate=$-(* ?)]
::        =/  b=(list _?>(?=(^ a) i.a))  ~
::        |-  ^-  (list _?>(?=(^ a) i.a))
::        ?~  a  (flop b)
::        ?.  (predicate i.a)  $(a t.a)
::        $(a t.a, b [i.a b])
::    Examples
::      > (where (limo ~[2 1 8]) |=(a=@ ?:(=(0 (mod a 2)) %.y %.n)))
::      ~[2 8]
++  where
  |*  [a=(list) predicate=$-(* ?)]
  =/  b=(list _?>(?=(^ a) i.a))  ~
  |-  ^-  (list _?>(?=(^ a) i.a))
  ?~  a  (flop b)
  ?.  (predicate i.a)  $(a t.a)
  $(a t.a, b [i.a b])
::

::    +windowed: [(list) window-size:@] -> (list)
::
::  Returns a list of sliding windows containing elements drawn from the input
::  list. Each window is returned as a fresh list.
::    Source
::    Examples
++  windowed  !!
::

::    +zip: [(list 'T1) (list 'T2)] -> (list ['T1 'T2])
::
::  Combines the two lists into a list of pairs. The two lists must have equal
::  lengths.
::    Source
::      ++  zip
::        |*  [a=(list) b=(list)]
::        =/  c=(list [_?>(?=(^ a) i.a) _?>(?=(^ b) i.b)])  ~
::        |-  ^-  (list [_?>(?=(^ a) i.a) _?>(?=(^ b) i.b)])
::        ?~  a  ?~  b  (flop c)  ~|("lists of unequal length" !!)
::        ?~  b  ~|("lists of unequal length" !!)
::        $(a t.a, b t.b, c [[i.a i.b] c])
::    Examples
::      > (zip `(list @)`~[1 2] `(list @)`~["aa" "bb"])
::      ~[[1 "aa"] [2 "bb"]]
++  zip
  |*  [a=(list) b=(list)]
  =/  c=(list [_?>(?=(^ a) i.a) _?>(?=(^ b) i.b)])  ~
  |-  ^-  (list [_?>(?=(^ a) i.a) _?>(?=(^ b) i.b)])
  ?~  a  ?~  b  (flop c)  ~|("lists of unequal length" !!)
  ?~  b  ~|("lists of unequal length" !!)
  $(a t.a, b t.b, c [[i.a i.b] c])
::    +zip3: [(list 'T1) (list 'T2) (list 'T3)] -> (list ['T1 'T2 'T3])
::
::  Combines the three lists into a list of triples. The lists must have equal
::  lengths.
::    Source
::      ++  zip3
::        |*  [a=(list) b=(list) c=(list)]
::        =/  d=(list [_?>(?=(^ a) i.a) _?>(?=(^ b) i.b) _?>(?=(^ c) i.c)])  ~
::        |-  ^-  (list [_?>(?=(^ a) i.a) _?>(?=(^ b) i.b) _?>(?=(^ c) i.c)])
::        ?~  a  ?~  b  ?~  c  (flop d)
::                      ~|("lists of unequal length" !!)
::               ~|("lists of unequal length" !!)
::        ?~  b   ~|("lists of unequal length" !!)
::        ?~  c   ~|("lists of unequal length" !!)
::        $(a t.a, b t.b, c t.c, d [[i.a i.b i.c] d])
::    Examples
::      > (zip3 `(list @)`~[1 2] `(list tape)`~["aa" "bb"] `(list @t)`~['a' 'b'])
::      ~[[1 "aa" 'a'] [2 "bb" 'b']]
++  zip3
  |*  [a=(list) b=(list) c=(list)]
  =/  d=(list [_?>(?=(^ a) i.a) _?>(?=(^ b) i.b) _?>(?=(^ c) i.c)])  ~
  |-  ^-  (list [_?>(?=(^ a) i.a) _?>(?=(^ b) i.b) _?>(?=(^ c) i.c)])
  ?~  a  ?~  b  ?~  c  (flop d)
                ~|("lists of unequal length" !!)
         ~|("lists of unequal length" !!)
  ?~  b   ~|("lists of unequal length" !!)
  ?~  c   ~|("lists of unequal length" !!)
  $(a t.a, b t.b, c t.c, d [[i.a i.b i.c] d])
--
