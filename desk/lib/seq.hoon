::  /lib/seq/hoon
::
::    operations for working with values of type list
::  ^list
|%
::
::  Returns a new list that contains all pairings of elements from two non-empty
::  lists.
::    Source
::      ++  all-pairs
::        |*  [p=(list) q=(list)]
::        =/  a=(list _?>(?=(^ p) i.p))  p
::        =/  res=(list [_?>(?=(^ p) i.p) _?>(?=(^ q) i.q)])  ~
::        =/  scnd=(list _?>(?=(^ q) i.q))  q
::        |-  ^-  (list [_?>(?=(^ p) i.p) _?>(?=(^ q) i.q)])
::        ?~  a  res
::        ?~  scnd  $(a t.a, scnd q)
::        $(res [[i.a i.scnd] res], scnd +.scnd)
::    Examples
::      > (all-pairs ~['a' 'b' 'c'] ~[1 2 3])
::      ~[['c' 3] ['c' 2] ['c' 1] 
::        ['b' 3] ['b' 2] ['b' 1]
::        ['a' 3] ['a' 2] ['a' 1]]
::  +allPairs: [(list t1) (list t2)] -> (list [t1 t2]) 
++  all-pairs
  |*  [p=(list) q=(list)]
  =/  a=(list _?>(?=(^ p) i.p))  p
  =/  res=(list [_?>(?=(^ p) i.p) _?>(?=(^ q) i.q)])  ~
  =/  scnd=(list _?>(?=(^ q) i.q))  q
  |-  ^-  (list [_?>(?=(^ p) i.p) _?>(?=(^ q) i.q)])
  ?~  a  res
  ?~  scnd  $(a t.a, scnd q)
  $(res [[i.a i.scnd] res], scnd +.scnd)
::
::  Returns a new list that contains the elements of the first list followed by
::  elements of the second list.
::    Source
::      ++  weld
::        ~/  %weld
::        |*  [a=(list) b=(list)]
::        =>  .(a ^.(homo a), b ^.(homo b))
::        |-  ^+  b
::        ?~  a  b
::        [i.a $(a t.a)]
::    Examples
::      > (append "urb" "it")
::      "urbit"
::      > (append (limo [1 2 ~]) (limo [3 4 ~]))
::      ~[1 2 3 4]
::  +append: [(list) (list)] -> (list)
++  append  weld
::

::
::  Returns the average of the values in a non-empty list.
::  +average: (list @) -> @ud
++  average
  |*  a=(list)
  !!
::

::
::  Returns the average of values in a list generated by applying a function to
::  each element of the list.
::  +average-by: [projection:(* -> @ud) (list *)] -> @ud
++  average-by  !!
::

::
::  Applies a function to each element in a list and then returns a list of
::  values v where the applied function returns (unit v). 
::  Returns an empty list when the input list is empty or when the applied
::  chooser function returns ~ for all elements.
::  +choose: [(list *) (* -> (unit v))] -> (list v)
::    Source
::      ++  murn
::        ~/  %murn
::        |*  [a=(list) b=$-(* (unit))]
::        =>  .(a (homo a))
::        |-  ^-  (list _?>(?=(^ a) (need (b i.a))))
::        ?~  a  ~
::        =/  c  (b i.a)
::        ?~  c  $(a t.a)
::        [+.c $(a t.a)]
::    Examples
::      > =a |=(a=@ ?.((gte a 2) ~ (some (add a 10))))
::      > (choose `(list @)`[0 1 2 3 ~] a)
::      [i=12 t=[i=13 t=~]]
++  choose  murn
::
::  Divides the input list into lists (chunks) with a positive number of at
::  most chunkSize elements. Returns a new list containing the generated lists
::  (chunks) as its elements. Returns an empty list when the input list is empty
::  +chunkBySize: [chunkSize:@ud (list *)] -> (list (list *))
::    Source
::      ++  chunk-by-size
::        |*  [p=@ud q=(list)]
::        =/  res=(list (list _?>(?=(^ q) i.q)))  ~
::        =/  i=@ud  0
::        =/  next=(list _?>(?=(^ q) i.q))  ~
::        |-  ^-  (list (list _?>(?=(^ q) i.q)))
::        ?~  q  (flop [(flop next) res])
::        ?:  =(i p)  $(i 0, res [(flop next) res], next ~)
::        $(i +(i), next [i.q next], q t.q)
::    Examples
::      > (chunk-by-size 2 (limo ~[1 2 3 4 5 6 7]))
::      [i=~[1 2] t=[i=~[3 4] t=~[~[5 6] ~[7]]]]
++  chunk-by-size
  |*  [p=@ud q=(list)]
  ?:  =(0 p)  ~|("non-zero size required" !!)
  =/  res=(list (list _?>(?=(^ q) i.q)))  ~
  =/  i=@ud  0
  =/  next=(list _?>(?=(^ q) i.q))  ~
  |-  ^-  (list (list _?>(?=(^ q) i.q)))
  ?~  q  (flop [(flop next) res])
  ?:  =(i p)  $(i 0, res [(flop next) res], next ~)
  $(i +(i), next [i.q next], q t.q)
::
::  For each element of the list, applies the given function. Concatenates all
::  the results and return the combined list.
::  +collect: [mapping:$-(* (list)) (list)] -> (list)
::    Source
::      ++  collect
::        |*  [a=$-(* (list)) b=(list)]
::        =/  res=(list)  ~
::        |-
::        ?~  b  (flop res)
::        =/  c  (a i.b)
::        |-
::        ?~  c  ^$(b t.b)
::        $(c t.c, res [i.c res])
::    Examples
::      > (collect |=(a=* (limo ~[a a])) (limo ~[1 2 3]))
::      ~[1 1 2 2 3 3]
++  collect
  |*  [a=$-(* (list)) b=(list)]
  =/  res=(list)  ~
  |-
  ?~  b  (flop res)
  =/  c=(list)  (a i.b)
  |-
  ?~  c  ^$(b t.b)
  $(c t.c, res [i.c res])
::
::  Compares two lists element by element using the given comparison function.
::  When an entry exists for both lists, returns the result of the comparer 
::  function. When the second list is longer than the first returns %.y for
::  entries of second where first does not exist. When first list is longer
::  returns %.n for entries of first where second does not exist.
::  +compare: [comparer:$-([* *] ?) (list) (list2)] -> (list ?)
::    Source
::      ++  compare
::        |*  [a=$-([* *] ?) b=(list) c=(list)]
::        =/  res=(list ?)  ~
::        =/  bb  b
::        =/  cc  c
::        |-  ^-  (list ?)
::        ?~  bb  ?~  cc  (flop res)  $(cc t.cc, res [%.y res])
::        ?~  cc  $(bb t.bb, res [%.n res])
::        $(bb t.bb, cc t.cc, res [(a i.bb i.cc) res])
::    Examples
::      > (compare aor "when" "than")
::      ~[%.n %.y %.n %.y]
++  compare
  |*  [a=$-([* *] ?) b=(list) c=(list)]
  =/  res=(list ?)  ~
  =/  bb  b
  =/  cc  c
  |-  ^-  (list ?)
  ?~  bb  ?~  cc  (flop res)  $(cc t.cc, res [%.y res])
  ?~  cc  $(bb t.bb, res [%.n res])
  $(bb t.bb, cc t.cc, res [(a i.bb i.cc) res])
::
::  Returns a new list that contains the elements of each the lists in order.
::  +concat: (list (list)) -> (list)
::    Source
::      ++  zing
::        ~/  %zing
::        =|  *
::        |@
::        ++  $
::          ?~  +<
::            +<
::          (welp +<- $(+< +<+))
::        --
::    Examples
::      > (concat (limo [(limo ['a' 'b' 'c' ~]) (limo ['e' 'f' 'g' ~]) 
::          (limo ['h' 'i' 'j' ~]) ~]))
::      ~['a' 'b' 'c' 'e' 'f' 'g' 'h' 'i' 'j']
::      > (concat (limo [(limo [1 'a' 2 'b' ~]) (limo [3 'c' 4 'd' ~]) ~]))
::      ~[1 97 2 98 3 99 4 100]
++  concat  zing
::
::  Tests if the list contains the specified element.
::  +contains: [value:* (list)] -> ?
::    Source
::      ++  contains
::        |*  [a=* b=(list)]
::        |-  ^-  ?
::        ?~  b  %.n
::        ?:  =(a i.b)  %.y
::        $(b t.b)
::    Examples
::      > (contains "yep" `(list tape)`~["nope" "yep"])
::      %.y
++  contains
  |*  [a=* b=(list)]
  |-  ^-  ?
  ?~  b  %.n
  ?:  =(a i.b)  %.y
  $(b t.b)
::
::  Applies a key-generating function to each element of a list and returns a
::  list yielding unique keys and their number of occurrences in the original
::  list.
::  +countBy: [projection:$-(* *) (list)] -> (list [* @ud])
::    Source


::    Examples
::      > (count-by:seq |=(a=tape (first-n:seq 2 a)) (limo ~["where" "when" "there" "then"]))
::      ~[[[i='t' t="h"] 2] [[i='w' t="h"] 2]]
++  count-by
  |*  [a=$-(* *) b=(list)]
::  ?~  b  ~
  =/  res=(map _?>(?=(^ b) (a i.b)) @ud)  ~
  |-  ^-  (list [_?>(?=(^ b) (a i.b)) @ud])
  ?~  b  ~(tap by res)
  =/  key=_?>(?=(^ b) (a i.b))  (a i.b)
  =/  val  (~(get by res) key)
  ?~  val  $(res `(map _?>(?=(^ b) (a i.b)) @ud)`(~(put by res) key 1), b t.b)
  $(res `(map _?>(?=(^ b) (a i.b)) @ud)`(~(put by res) key +(`@ud`(need val))), b t.b)
::
::  Returns a list that contains no duplicate entries according to generic hash
::  and equality comparisons on the entries. If an element occurs multiple times
::  in the list then the later occurrences are discarded.
::  +distinct: list
++  distinct  !!
::

::
::  Returns a list that contains no duplicate entries according to the generic
::  hash and equality comparisons on the keys returned by the given
::  key-generating function. If an element occurs multiple times in the list
::  then the later occurrences are discarded.
::  +distinctBy: projection list
++  distinct-by  !!
::

::
::  Returns an empty list of the given type.
::  +empty: 
++  empty  !!
::

::
::  Returns the only element of the list.
::  +exactlyOne: list
++  exactly-one  !!
::

::
::  Returns a new list with the distinct elements of the input list which do not
::  appear in the itemsToExclude sequence, using generic hash and equality
::  comparisons to compare values.
::  +except: itemsToExclude list
++  except  !!
::

::
::  Tests if any element of the list satisfies the given predicate.
::  +exists: predicate list
++  exists  !!
::

::
::  Tests if any pair of corresponding elements of the lists satisfies the given
::  predicate.
::  +exists2: predicate list1 list2
++  exists2  !!
::

::
::  Returns a new collection containing only the elements of the collection for
::  which the given predicate returns "true"
::  +filter: list [(list) predicate=$-(* ?)]
::    Source
::      ++  skim
::        ~/  %skim
::        |*  [a=(list) b=$-(* ?)]
::        |-
::        ^+  a
::        ?~  a  ~
::       ?:((b i.a) [i.a $(a t.a)] $(a t.a))
::    Examples
::      > =a |=(a=@ (gth a 1))
::      > (filter `(list @)`[0 1 2 3 ~] a)
::      [i=2 t=~[3]]
++  filter  skim
::

::
::  Returns the first element for which the given function returns True. 
::  KeyNotFoundException if no such element exists.
::  +find: predicate list
++  find  !!
::

::
::  Returns the last element for which the given function returns True. 
:: Raises KeyNotFoundException if no such element exists.
::  +findBack: predicate list
++  find-back  !!
::

::
::  Returns the index of the first element in the list that satisfies the given
::  predicate. Raises KeyNotFoundException if no such element exists.
::  +findIndex: predicate list
++  find-index  !!
::

::
::  Returns the index of the last element in the list that satisfies the given
::  predicate. Raises KeyNotFoundException if no such element exists.
::  +findIndexBack: predicate list
++  find-index-back  !!
::

::
::  Returns the first N elements of the list.
::  +first-n: [count:@ud (list *)] -> (list *)
::    Source
::      ++  scag
::        ~/  %scag
::        |*  [a=@ b=(list)]
::        |-  ^+  b
::        ?:  |(?=(~ b) =(0 a))  ~
::        [i.b $(b t.b, a (dec a))]
::    Examples
::      > (scag 2 `(list @)`[1 2 3 4 ~])
::      [i=1 t=~[2]]
::      > (scag 10 `(list @)`[1 2 3 4 ~])
::      [i=1 t=~[2 3 4]]
++  first-n  scag

::
::  Applies a function to each element of the collection, threading an
::  accumulator argument through the computation. Take the second argument, and
::  apply the function to it and the first element of the list. Then feed this
::  result into the function along with the second element and so on. Return the
::  final result. If the input function is f and the elements are i0...iN then
::  computes f (... (f s i0) i1 ...) iN.
::  +fold: folder state list
++  fold  !!
::

::
::  Applies a function to corresponding elements of two collections, threading
::  an accumulator argument through the computation. The collections must have
::  identical sizes. If the input function is f and the elements are i0...iN and
::  j0...jN then computes f (... (f s i0 j0)...) iN jN.
::  +fold2: folder state list1 list2
++  fold2  !!
::

::
::  Applies a function to each element of the collection, starting from the end,
::  threading an accumulator argument through the computation. If the input
::  function is f and the elements are i0...iN then computes f i0 (...(f iN s)).
::  +foldBack: folder list state
++  fold-back  !!
::

::
::  Applies a function to corresponding elements of two collections, threading
::  an accumulator argument through the computation. The collections must have
::  identical sizes. If the input function is f and the elements are i0...iN and
::  j0...jN then computes f i0 j0 (...(f iN jN s)).
::  +foldBack2: folder list1 list2 state
++  fold-back2  !!
::

::
::  Tests if all elements of the collection satisfy the given predicate.
::  +forall: predicate list
++  forall  !!
::

::
::  Tests if all corresponding elements of the collection satisfy the given
::  predicate pairwise.
::  +forall2: predicate list1 list2
++  forall2  !!
::

::
::  Applies a key-generating function to each element of a list and yields a
::  list of unique keys. Each unique key contains a list of all elements that
::  match to this key.
::  +groupBy: projection list
++  group-by  !!
::

::
::  Returns the first element of the list.
::  +head: list
++  head  !!
::

::
::  Returns a new list whose elements are the corresponding elements of the
::  input list paired with the index (from 0) of each element.
::  +indexed: list
++  indexed  !!
::

::
::  Creates a list by calling the given generator on each index.
::  +init: length initializer
++  init  !!
::

::
::  Return a new list with a new item inserted before the given index.
::  +insert-at: [(list) index=@ value=*] -> (list)
::    Source
::    ++  into
::      ~/  %into
::      |*  [a=(list) b=@ c=*]
::      ^+  a
::      (weld (scag b a) [c (slag b a)])
::    Examples
::    > (insert-at (limo ~[2 3 4]) 1 11)
::    ~[2 11 3 4]
++  insert-at  into
::
::  Return a new list with new items inserted before the given index.
::  +insertManyAt: index values source
++  insert-many-at  !!
::

::
::  Returns true if the list contains no elements, false otherwise.
::  +isEmpty: list
++  is-empty  !!
::

::
::  Indexes into the list. The first element has index 0.
::  +item: index list
++  item  !!
::

::
::  Returns the length of the list.
::  +length: (list *) -> @ud
::    Source
::      ++  lent
::        ~/  %lent
::        |=  a=(list)
::        ^-  @
::        =+  b=0
::        |-
::        ?~  a  b
::        $(a t.a, b +(b))
::    Examples
::      > (length [1 2 3 4 ~])
::      4
::      > (length [1 'a' 2 'b' (some 10) ~])
::      5
++  length  lent
::
::
::  Builds a new list whose elements are the results of applying the given
::  gate to each of the elements of the list.
::  +map-elements: [(list) mapping:(* -> *)] -> (list)
::    Source
::      ++  turn
::        ~/  %turn
::        |*  [a=(list) b=gate]
::        =>  .(a (homo a))
::        ^-  (list _?>(?=(^ a) (b i.a)))
::        |-
::        ?~  a  ~
::        [i=(b i.a) t=$(a t.a)]
::    Examples
::      > (map (limo [104 111 111 110 ~]) @t)
::      <|h o o n|>
::      > =a |=(a=@ (add a 4))
::      > (map (limo [1 2 3 4 ~]) a)
::      ~[5 6 7 8]
++  map-elements  turn
::

::
::  Builds a new collection whose elements are the results of applying the given
::  function to the corresponding elements of the two collections pairwise.
::  +map2: mapping list1 list2
++  map2  !!
::

::
::  Builds a new collection whose elements are the results of applying the given
::  function to the corresponding elements of the three collections
::  simultaneously.
::  +map3: mapping list1 list2 list3
++  map3  !!
::

::
::  Combines map and fold. Builds a new list whose elements are the results of
::  applying the given function to each of the elements of the input list. The
::  function is also used to accumulate a final value.
::  +mapFold: mapping state list
++  map-fold  !!
::

::
::  Combines map and foldBack. Builds a new list whose elements are the results
::  of applying the given function to each of the elements of the input list.
::  The function is also used to accumulate a final value.
::  +mapFoldBack: mapping list state
++  map-fold-back  !!
::

::
::  Builds a new collection whose elements are the results of applying the given
::  function to each of the elements of the collection. The integer index passed
::  to the function indicates the index (from 0) of element being transformed.
::  +mapi: mapping list
++  mapi  !!
::

::
::  Like mapi, but mapping corresponding elements from two lists of equal length.
::  +mapi2: mapping list1 list2
++  mapi2  !!
::

::
::  Return the greatest of all elements of the list, compared via Operators.max.
::  +max: list
++  max  !!
::

::
::  Returns the greatest of all elements of the list, compared via Operators.max
::  on the function result.
::  +maxBy: projection list
++  max-by  !!
::

::
::  Returns the lowest of all elements of the list, compared via Operators.min.
::  +min: list
++  min  !!
::

::
::  Returns the lowest of all elements of the list, compared via Operators.min
::  on the function result
::  +minBy: projection list
++  min-by  !!
::
::  Returns a list of each element in the input list and its predecessor, with
::  the exception of the first element which is only returned as the predecessor
::  of the second element.
::  +pairwise: list
++  pairwise  !!
::

::
::  Splits the collection into two collections, containing the elements for
::  which the given predicate returns True and False respectively. Element order is preserved in both of the created lists.
::  +partition: [(list) predicate==$-(* ?)] -> [(list) (list)]
::    Source
::      ++  skid
::        ~/  %skid
::        |*  [a=(list) b=$-(* ?)]
::        |-  ^+  [p=a q=a]
::        ?~  a  [~ ~]
::        =+  c=$(a t.a)
::        ?:((b i.a) [[i.a p.c] q.c] [p.c [i.a q.c]])
::    Examples
::      > =a |=(a=@ (gth a 1))
::      > (partition `(list @)`[0 1 2 3 ~] a)
::      [p=[i=2 t=~[3]] q=[i=0 t=~[1]]]
++  partition  skid
::

::
::  Returns a list with all elements permuted according to the specified permutation.
::  +permute: indexMap list
++  permute  !!
::

::
::  Applies the given function to successive elements, returning the first
::  result where function returns Some(x) for some x. If no such element exists
::  then raise KeyNotFoundException
::  +pick: chooser list
++  pick  !!
::

::
::  Apply a function to each element of the collection, threading an accumulator
::  argument through the computation. Apply the function to the first two
::  elements of the list. Then feed this result into the function along with the
::  third element and so on. Return the final result. If the input function is f
::  and the elements are i0...iN then computes f (... (f i0 i1) i2 ...) iN.
::  +reduce: reduction list
++  reduce  !!
::

::
::  Applies a function to each element of the collection, starting from the end,
::  threading an accumulator argument through the computation. If the input
::  function is f and the elements are i0...iN then computes 
::  f i0 (...(f iN-1 iN)).
::  +reduceBack: reduction list
++  reduce-back  !!
::

::
::  Return a new list with the item at a given index removed.
::  +removeAt: index source
++  remove-at  !!
::

::
::  Return a new list with the number of items starting at a given index removed
::  +removeManyAt: [index=@ count=@ (list)] -> (list)
::    Source
::      ++  oust
::        ~/  %oust
::        |*  [[a=@ b=@] c=(list)]
::        (weld (scag +<-< c) (slag (add +<-< +<->) c))
::    Examples
::      > (remove-many-at [4 5] "good day, urbit!")
::      "good urbit!"
::      > (remove-many-at [2 2] `(list @)`[1 2 3 4 ~])
::      ~[1 2]
++  remove-many-at  oust  :: to do: list is always first parm
::
::
::  Creates a list by replicating the given initial value.
::  +replicate: [count=@ initial=*] -> (list *)
::    Source
::      ++  reap
::        ~/  %reap
::        |*  [a=@ b=*]
::        |-  ^-  (list _b)
::        ?~  a  ~
::        [b $(a (dec a))]
::    Examples
::      > (replicate 20 %a)
::      ~[%a %a %a %a %a %a %a %a %a %a %a %a %a %a %a %a %a %a %a %a]
::      > (replicate 5 ~s1)
::      ~[~s1 ~s1 ~s1 ~s1 ~s1]
::      > `@dr`(roll (replicate 5 ~s1) add)
::      ~s5
++  replicate  reap
::

::
::  Returns a new list with the elements in reverse order.
::  +reverse: list
::    Source
::      ++  flop
::        ~/  %flop
::        |*  a=(list)
::        =>  .(a (homo a))
::        ^+  a
::        =+  b=`_a`~
::        |-
::        ?~  a  b
::        $(a t.a, b [i.a b])
::    Examples
::      > =a [1 2 3 ~]
::      > (flop a)
::      ~[3 2 1]
::      > (flop (flop a))
::      ~[1 2 3]
++  reverse  flop
::
::  Applies a function to each element of the collection, threading an
::  accumulator argument through the computation. Take the second argument, and
::  apply the function to it and the first element of the list. Then feed this
::  result into the function along with the second element and so on. Returns
::  the list of intermediate results and the final result.
::  +scan: folder state list
++  scan  !!
::

::
::  Like foldBack, but returns both the intermediary and final results
::  +scanBack: folder list state
++  scan-back  !!
::

::
::  Returns a list that contains one item only.
::  +singleton: value
++  singleton  !!
::

::
::  Returns the list after removing the first N elements.
::  +skip: count list
++  skip  !!
::

::
::  Bypasses elements in a list while the given predicate returns True, and then
::  returns the remaining elements of the list.
::  +skipWhile: predicate list
++  skip-while  !!
::

::
::  Sorts the given list using Operators.compare.
::  +sort: list
++  sort  !!
::

::
::  Sorts the given list using keys given by the given projection. Keys are
::  compared using Operators.compare.
::  +sortBy: projection list
++  sort-by  !!
::

::
::  Sorts the given list in descending order using keys given by the given
::  projection. Keys are compared using Operators.compare.
::  +sortByDescending: projection list
++  sort-by-descending  !!
::

::
::  Sorts the given list in descending order using Operators.compare.
::  +sortDescending: list
++  sort-descending  !!
::

::
::  Sorts the given list using the given comparison function.
::  +sortWith: comparer list
++  sort-with  !!
::

::
::  Splits a list into two lists, at the given index.
::  +splitAt: index list
++  split-at  !!
::

::
::  Splits the input list into at most count chunks.
::  +splitInto: count list
++  split-into  !!
::

::
::  Returns the sum of the elements in the list.
::  +sum: list
++  sum  !!
::

::
::  Returns the sum of the results generated by applying the function to each
::  element of the list.
::  +sumBy: projection list
++  sum-by  !!
::

::
::  Returns the list after removing the first element.
::  +tail: list
++  tail  !!
::

::
::  Returns the last element of the list.
::  +tail-end: (list) -> *
::    ArgumentException:  Crash when the input does not have any elements.
::    Source
::      ++  rear
::        ~/  %rear
::        |*  a=(list)
::        ^-  _?>(?=(^ a) i.a)
::        ?>  ?=(^ a)
::        ?:  =(~ t.a)  i.a
::        $(a t.a)
::    Examples
::      > (last ~[1 2 3])
::      3
::      > (last ~)
::      hoon expression failed
++  tail-end  rear

::
::
::  Returns a list that contains all elements of the original list while the
::  given predicate returns True, and then returns no further elements.
::  +takeWhile: predicate list
++  take-while  !!
::

::
::  Returns the transpose of the given sequence of lists.
::  +transpose: lists
++  transpose  !!
::

::
::  Returns at most N elements in a new list.
::  +truncate: count list
++  truncate  !!
::

::
::  Returns the only element of the list or None if it is empty or contains more
::  than one element.
::  +tryExactlyOne: list
++  try-exactly-one  !!
::

::
::  Returns the first element for which the given function returns True.
::  Return None if no such element exists.
::  +tryFind: predicate list
++  try-find  !!
::

::
::  Returns the last element for which the given function returns True.
::  Return None if no such element exists.
::  +tryFindBack: predicate list
++  try-find-back  !!
::

::
::  Returns the index of the first element in the list that satisfies the given
::  predicate. Return None if no such element exists.
::  +tryFindIndex: predicate list
++  try-find-index  !!
::

::
::  Returns the index of the last element in the list that satisfies the given
::  predicate. Return None if no such element exists.
::  +tryFindIndexBack: predicate list
++  try-find-index-back  !!
::

::
::  Returns the first element of the list, or None if the list is empty.
::  +tryHead: list
++  try-head  !!
::

::
::  Tries to find the nth element in the list. Returns None if index is negative
::  or the list does not contain enough elements.
::  +tryItem: index list
++  try-item  !!
::

::
::  Returns the last element of the list. Return None if no such element exists.
::  +tryLast: list
++  try-last  !!
::

::
::  Applies the given function to successive elements, returning Some(x) the
::  first result where function returns Some(x) for some x.
::  If no such element exists then return None.
::  +tryPick: chooser list
++  try-pick  !!
::

::
::  Returns a list that contains the elements generated by the given computation
::  The generator is repeatedly called to build the list until it returns None.
::  The given initial state argument is passed to the element generator.
::  +unfold: generator state
++  unfold  !!
::

::
::  Splits a list of pairs into two lists.
::  +unzip: list
++  unzip  !!
::

::
::  Splits a list of triples into three lists.
::  +unzip3: list
++  unzip3  !!
::

::
::  Return a new list with the item at a given index set to the new value.
::  +updateAt: index value source
++  update-at  !!
::

::
::  Returns a new list containing only the elements of the list for which the
::  given predicate returns "true"
::  +where: predicate list
++  where  !!
::

::
::  Returns a list of sliding windows containing elements drawn from the input
::  list. Each window is returned as a fresh list.
::  +windowed: windowSize list
++  windowed  !!
::

::
::  Combines the two lists into a list of pairs. The two lists must have equal
::  lengths.
::  +zip: list1 list2
++  zip  !!
::

::
::  Combines the three lists into a list of triples. The lists must have equal
::  lengths.
::  +zip3: list1 list2 list3
++  zip3  !!
::
--
